#!/usr/bin/env python
# This is a module for working with the remote CamHD Quicktime files in the
# raw data archive. It can be used to obtain information about these files
# or individual frames without downloading them in their entirety.
#
# Timothy Crone (tjcrone@gmail.com)

# imports
import subprocess, struct, sys
#os, time, argparse

# get arbitrary bytes from remote file
def get_bytes(filename, byte_range):
  cmd = ('curl --header "Range: bytes=%i-%i" -k -s ' % 
    (byte_range[0], byte_range[1])) + filename
  p = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=True)
  file_bytes = p.communicate()[0]
  return file_bytes

# get big-endian integer from remote file
def get_integer(filename, byte_range):
  file_bytes = get_bytes(filename, byte_range)
  if len(file_bytes) == 4:
    return struct.unpack('>I', file_bytes)[0]
  elif len(file_bytes) ==8:
    return struct.unpack('>Q', file_bytes)[0]
  # check and warn or error if not an integer

# get the top-level atom sizes
def get_atom_sizes(filename):
  byte_range = [0, 3]
  ftyp_size = get_integer(filename, byte_range)
  # check and warn or error if ftyp_size not 24
  byte_range = [ftyp_size, ftyp_size + 3]
  mdat_size = get_integer(filename, byte_range)
  if mdat_size == 1:
    byte_range = [ftyp_size + 8, ftyp_size + 15]
    mdat_size = get_integer(filename, byte_range)
  byte_range = [ftyp_size + mdat_size, ftyp_size + mdat_size + 3]
  moov_size = get_integer(filename, byte_range)
  return ftyp_size, mdat_size, moov_size

# get the moov atom
def get_moov_atom(filename):
  (ftyp_size, mdat_size, moov_size) = get_atom_sizes(filename)
  byte_range = [ftyp_size + mdat_size, ftyp_size + mdat_size + moov_size]
  return get_bytes(filename, byte_range)
  # check moov atom sanity

# get frame count
def get_frame_count(filename, moov_atom):
  # get the moov_atom if not provided (internally, only download moov atom once)
  if not provided, moov_atom = get_moov_atom(filename)


# get frame sizes from moov atom
#def get_frame_sizes(filename):


# get frame_positions(filename):


#get_frame_sizes

#get_frame_count



# return string of hex zeros
def hex_zeros(count):
  zeros = []
  for i in range(0, count):
    zeros.append(b'\x00')
  return zeros

# build simple avi header
def build_header():
  avi_header = ''.join([b'\x52\x49\x46\x46\xaa\x32\x09\x00\x41\x56\x49\x20\x4c\x49\x53\x54',
    b'\x38\x12\x00\x00\x68\x64\x72\x6c\x61\x76\x69\x68\x38\x00\x00\x00',
    b'\x2b\x41\x00\x00\xc3\x3d\x09\x01\x00\x00\x00\x00\x10\x09\x00\x00',
      b'\x02\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x10\x00',
    b'\x80\x07\x00\x00\x38\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
    b'\x00\x00\x00\x00\x00\x00\x00\x00\x4c\x49\x53\x54\xe0\x10\x00\x00',
    b'\x73\x74\x72\x6c\x73\x74\x72\x68\x38\x00\x00\x00\x76\x69\x64\x73',
    b'\x61\x70\x63\x6e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
    b'\xe9\x03\x00\x00\x60\xea\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00',
    b'\x00\x1c\x09\x00\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00',
    b'\x80\x07\x38\x04\x73\x74\x72\x66\x28\x00\x00\x00\x28\x00\x00\x00',
    b'\x80\x07\x00\x00\x38\x04\x00\x00\x01\x00\x18\x00\x61\x70\x63\x6e',
    b'\x00\xec\x5e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
    b'\x00\x00\x00\x00\x4a\x55\x4e\x4b\x18\x10\x00\x00\x04\x00\x00\x00',
    b'\x00\x00\x00\x00\x30\x30\x64\x63\x00\x00\x00\x00\x00\x00\x00\x00'] + \
    hex_zeros(4096) + \
    [b'\x00\x00\x00\x00\x76\x70\x72\x70\x44\x00\x00\x00\x00\x00\x00\x00',
    b'\x00\x00\x00\x00\x3c\x00\x00\x00\x80\x07\x00\x00\x38\x04\x00\x00',
    b'\x09\x00\x10\x00\x80\x07\x00\x00\x38\x04\x00\x00\x01\x00\x00\x00',
    b'\x38\x04\x00\x00\x80\x07\x00\x00\x38\x04\x00\x00\x80\x07\x00\x00',
    b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
    b'\x4a\x55\x4e\x4b\x04\x01\x00\x00\x6f\x64\x6d\x6c\x64\x6d\x6c\x68\xf8'] + \
    hex_zeros(239) + \
    [b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x4c\x49\x53\x54',
    b'\x1a\x00\x00\x00\x49\x4e\x46\x4f\x49\x53\x46\x54\x0e\x00\x00\x00',
    b'\x4c\x61\x76\x66\x35\x37\x2e\x31\x39\x2e\x31\x30\x30\x00\x4a\x55',
    b'\x4e\x4b\xf8\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'] + \
    hex_zeros(1006) + \
    [b'\x4c\x49\x53\x54\x14\x1c\x09\x00\x6d\x6f\x76\x69\x30\x30\x64\x63\x00\x1c\x09\x00'])
  return avi_header

#get_frame (filename, frame number,  output format option)

#get_fram_range?


# main function to run when called directly
def main():

  # file to test
  filename = 'https://rawdata.oceanobservatories.org/files/RS03ASHS/PN03B/06-CAMHDA301/2016/11/13/CAMHDA301-20161113T000000Z.mov'

  # check moov atom
  #moov_atom = get_moov_atom(filename)
  #sys.stdout.write(moov_atom)


  #frame_sizes = get_frame_sizes(filename)

# main sentinel
if __name__ == "__main__":
  main()

# scratch
#print struct.unpack('>I', moov_atom[0:4])[0]

#print struct.unpack('>I', moov_atom[8:12])[0]

#print(str(ftyp_size) + ' ' + str(mdat_size) + ' ' + str(moov_atom.find('stsz')))

# for now assume that we have a frame position and size obtained from the moov atom
#frame_position = [6094104432]
#frame_size = [596992]

# download the frame data
#byte_range = [frame_position[0], frame_position[0]+frame_size[0]-1]
#frame_data = get_frame_data(filename, byte_range)

# attach an avi header
# this header is a total kluge. it should be rewritten based on the avi spec.

#avi_file = avi_header + frame_data
#sys.stdout.write(avi_file)

# write this avi to a temporary file
#f = open('tmpavifile.avi', 'w')
#f.write(avi_file)
#f.close()

# convert to yuv rawvideo 
#  cmd = ('curl --header "Range: bytes=%i-%i" -k -s ' % 
#    (byte_range[0], byte_range[1])) + filename
#  p = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=True)

# parse command line argument
#filename = sys.argv[1]
